(defun MY-LENGTH (x)
    (cond ((null x) 0)
        (T (+ 1 (my-length (cdr x)))))
)

(defun MY-MEMQ (A L) 
    (cond ((null L) nil)
    ( (eq (car L) A) (cons (car L) (cdr L)))
    ( T (MY-MEMQ A (cdr L))))
)

(defun MY-APPEND (L1 L2)
    (cond ((null L1) L2)
    (t (cons (car L1) (MY-APPEND (cdr L1) L2))))
)

(defun MY-REVERSE (L1)
    (cond ((null L1) nil)
    (t (MY-APPEND (MY-REVERSE (cdr L1)) (list (car L1)))))
)

(defun MY-MAPCAR (F L) 
    (cond ((null L) nil)
    (t (cons (apply F (list (car L))) (MY-MAPCAR F (cdr L)))))
)

(defun MY-COPY (L)
    (cond ((atom L) L)
    ((consp L) L)
    (cons (MY-COPY (car L)) (MY-COPY (cdr L))))
)

(defun MY-NTH (L N)
    (cond ((eq N 0) (cons nil L))
    ((null L) nil)
    ((eq N 1) L)
    (t (MY-NTH (cdr L) (1- N))))
)

(defun MY-REMOVE (X L)
    (cond ((null L) nil)
    ((equal X (car L)) (MY-REMOVE X (cdr L)))
    (t (cons (car L) (MY-REMOVE X (cdr L)))))
)

(defun MY-SUBST (X Y Z)
    (cond ((null Z) nil)
    ((equal X (car Z)) (cons Y (MY-SUBST X Y (cdr Z))))
    ((listp (car Z)) (cons (MY-SUBST X Y (car Z)) (MY-SUBST X Y (cdr Z))))
    (t (cons (car Z) (MY-SUBST X Y (cdr Z)))))
)

(defun MY-MERGE (L1 L2)
    (cond ((null L1) L2)
    ((null L2) L1)
    ((<= (car L1) (car L2)) (cons (car L1) (MY-MERGE (cdr L1) L2)))
    (t (cons (car L2) (MY-MERGE L1 (cdr L2)))))

)

(defun sublist-helper (l1 l2)
    (cond ((null l1) t)
        ((eq (car l1) (car l2)) (sublist-helper (cdr l1) (cdr l2))))
)

(defun MY-SUBLIST (l1 l2)
    (cond ((null l2) nil)
        ((eq (car l1) (car l2)) (sublist-helper (cdr l1) (cdr l2)))
        (t (MY-SUBLIST l1 (cdr l2))))
)
